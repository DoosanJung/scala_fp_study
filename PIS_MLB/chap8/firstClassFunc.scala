#!/usr/bin/env scala
/*
Function values are objects, so you can store them in variables if you like.
They are functions, too,  so you can invoke them
using the usual parentheses function-call notation.
*/
var increase = (x:Int) => x+1
println(increase(10))

// increase is a var, you can reassign it a different function later on.
increase = (x:Int) => x+9999
println(increase(10))

//if  you have more than one statement in the function literal..
increase = (x:Int) => {
  println("we")
  println("are")
  println("here")
  x+1
}

println(increase(10))

//foreach method takes a function as an argument and invokes that function on each of its elements
val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers.foreach((x:Int) => println(x))

//collection types also have a filter method
println(someNumbers.filter((x:Int) => x>0))

//more briefly ..
println(someNumbers.filter((x) => x>0)) //target typing, 'list of integer' => 'integer x'
println(someNumbers.filter(x => x>0)) //leave out the () around a parameter whose type is inferred

//placeholder syntax
println(someNumbers.filter(_>0)) //underscore as a 'blank' that needs to be 'filled in'

//val f = _ + _ will throw an error: missing parameter type for expanded function..
val f = (_:Int) + (_:Int)
println(f(5,10))
/*NOTE: multiple underscores mean multiple parameters,
not reuse of a single parameter repeatedly.
*/

//partially applied function
/*
The underscore in this case is not a placeholder for a single parameter.
It is a placeholder for an entire parameter list.
*/
someNumbers.foreach(println _)

def sum(a:Int, b:Int, c:Int) = a + b + c
println(sum(1,2,3))

//instead..
val a = sum _ //partially applied func can be stored in a variable
//val a = sum will throw an error: missing arguments for method sum...
println(a(1,2,3))
/* var a refers to a function value object.
This function value is an instance of a class generated automatically
by the Scala compiler from sum _ , the partially applied function expression.
The class generated by the compiler has an apply method that takes three
arguments.
*/
println(a.apply(1,2,3))

//you can supply "some" but not all of the required arguments.
//this is why it's called "partially applied function"
val b = sum(1, _:Int, 3)
println(b(2)) //first and third arguments are already fixed with 1 and 3, respectively
